# AI 페어프로그래밍: 마인드셋 혁명

> "코딩 잘하는 사람이 아니라, **무엇을 만들어야 하는지 아는 사람**이 이긴다"

---

## 왜 마인드셋이 먼저인가?

### 기존 학습 방식의 한계

```
[기존 방식]
기초 → 중급 → 고급 → 실무
A to Z 순서대로, 체계적으로, 오랜 시간 투자

[문제점]
- AI 시대에는 학습 속도를 따라갈 수 없음
- 도구가 매달 바뀌는데 도구 학습에 집중?
- 기초를 다 배우고 나면 이미 세상이 바뀌어 있음
```

### 새로운 접근법: Recursive Gap Filling

```
[새로운 방식]
실제 문제 → AI에게 물어보기 → 모르면 더 깊이 → 전체 구조 파악

1. 실제 문제를 먼저 접한다
2. AI에게 해결 방법을 묻고 코드를 생성한다
3. 이해 안 되면 "12살에게 설명하듯이" 다시 묻는다
4. 반복하다 보면 전체 구조가 보인다
```

**핵심**: 기초부터 쌓는 게 아니라, 필요한 것을 그때그때 채워가며 배운다.

---

## 핵심 마인드셋 전환

### 1. 코더에서 오케스트레이터로

| 예전 | 지금 |
|------|------|
| 직접 연주하는 연주자 | 전체 곡을 지휘하는 지휘자 |
| 문제 → 직접 해결 | 문제 찾기 + 전달 + 검증 |
| 코드 치는 시간 ↑ | 문제 정의 + 검증 시간 ↑ |

**오케스트레이터의 역할:**
- **악보 해석 (요구사항)** — 무엇을 연주할지 명확히 정의
- **템포 조절 (검증)** — AI가 산으로 가지 않게
- **화음 조율 (통합)** — 여러 모듈이 잘 어우러지게

### 2. 마스터셰프 마인드

```
직접 요리하는 셰프 ✗
주방을 지휘하는 마스터셰프 ✓

AI는 당신의 수셰프입니다.
레시피(요구사항)를 명확히 전달하고,
결과물을 검증하세요.
```

### 3. 고민을 아웃소싱하세요

```
"이 문제 어떻게 풀지?" 혼자 고민 ✗
"같이 생각해보자" AI에게 던지기 ✓

생각 자체를 AI와 나누세요.
```

---

## AI 페어프로그래밍의 세 가지 요소

### Model × Harness × Pilot

```
┌─────────────────────────────────────────────────────┐
│                                                      │
│   Model      ×      Harness      ×      Pilot       │
│   (AI 모델)        (도구/환경)         (당신)        │
│                                                      │
└─────────────────────────────────────────────────────┘
```

**Model**: 어떤 프론티어 LLM을 사용하느냐 (Claude, GPT 등)
- 순위에 집착할 필요 없음, 어차피 매달 바뀜

**Harness**: Model을 둘러싼 도구와 환경
- Agent (Cursor, Claude Code, Cline)
- Tools (파일, 웹, API, 터미널)
- Context (CLAUDE.md, .cursorrules)
- 가볍게 유지할수록 Model이 집중

**Pilot**: 가장 중요한 요소 = 당신
- 문제 분해 — 복잡한 문제를 AI가 처리 가능한 단위로
- 실패 패턴 인식 — 할루시네이션, 컨텍스트 한계 예측
- 도메인 지식 — AI 출력의 적절성을 즉시 판단
- 파이프라인 설계 — 반복 가능한 워크플로우 구축

---

## 3일 과정 핵심 요약

### Day 1: 입문 - 마인드셋 장착

**핵심 메시지:**
- 현재 AI 성능의 10%도 활용 못하고 있다
- 챗봇 시대(질문→답변)에서 Agent 시대(작업 위임→실행→검증)로
- 바이브코딩: "코드가 존재한다는 것 자체를 잊어버리는 코딩"
- 질문을 두려워하지 마세요 - AI는 절대 당신을 판단하지 않습니다

**실습:**
- Claude Code / Cursor 설치 및 첫 대화
- "이 함수 설명해줘" → "좀 더 쉽게" → "왜?" 반복 질문
- Agent에게 작업 시키고 관찰하기

### Day 2: Context Engineering & 파이프라인

**핵심 메시지:**
- 맥락(Context)이 품질을 결정한다
- 같은 AI, 같은 요청이라도 맥락에 따라 결과가 완전히 다름
- CLAUDE.md = 프로젝트의 맥락을 알려주는 파일

**CLAUDE.md 필수 섹션:**
```markdown
# Project: [프로젝트명]

## 코딩 컨벤션
- 함수명: snake_case
- 들여쓰기: 4 spaces

## 빌드 & 테스트
make build
make test

## 절대 금지
- 동적 메모리 할당 ❌
- printf 직접 사용 ❌

## 필수 사항
- 모든 함수에 주석
- 에러 핸들링 명시적으로
```

**Rule-Growing Development:**
```
AI한테 시키기 → 이상한 짓 관찰 → 룰 추가 → 반복
```
CLAUDE.md가 점점 정교해집니다.

**파이프라인 설계:**
```
요구사항 분석 → PRD 작성 → TDD 개발 → 코드 리뷰 → 검증
        ↑_____________________________|  (루프백)
```

### Day 3: Agentic Workflow, MCP & Agent SDK

**핵심 메시지:**
- AI 모델은 누구나 같은 걸 쓴다
- **차별화는 워크플로우에서 나온다**
- 남의 워크플로우 복사 ✗, 패턴 학습 후 내 것으로 ✓

**확장 시스템:**
| 요소 | 역할 |
|------|------|
| Skills | 워크플로우를 /명령어로 패키징 |
| Commands | 커스텀 단축 명령어 |
| Hooks | 이벤트 기반 자동 트리거 (PreToolUse, PostToolUse, Stop) |
| MCP | 외부 도구(Context7, GitHub 등) 연결 |
| Agent SDK | 프로그래밍 방식 에이전트 구축 |

**10-Phase 워크플로우:**
```
[1.INIT]      상태 파일 + 훅 등록
[2.ANALYZE]   요구사항 분석 (REQ/AC 정의)
[3.REQ-VERIFY] ★ 병렬 3개 에이전트 (완전성/명확성/실현가능성)
[4.EXPLORE]   코드베이스 탐색 (병렬 3개)
[5.DESIGN]    아키텍처 설계 (병렬 3개 접근법)
[6.DESIGN-VERIFY] ★ 병렬 3개 에이전트 (타당성/호환성/유지보수성)
[7.IMPLEMENT] 코드 작성
[8.CODE-VERIFY] ★ 병렬 4개 에이전트 (verify-work)
[9.TEST]      테스트 + 커버리지 90%+
[10.COMPLETE] 완료 보고서 + 훅 제거
```

**병렬 Agent 패턴:**
```
검증 시작
├─ Agent 1: 완전성 검증
├─ Agent 2: 명확성 검증
├─ Agent 3: 실현가능성 검증
└─ Agent 4: 보안 검증
        ↓
    결과 종합 (신뢰도 필터링) → 최종 판정
```

**Agent SDK 기본 사용법:**
```python
from claude_code_sdk import Agent, Swarm

# 단일 에이전트
agent = Agent(
    name="code-reviewer",
    model="sonnet",
    prompt="MISRA C 2012 기준으로 코드를 검토하세요."
)
result = await agent.run(task="src/gc_module.c 리뷰해주세요")

# 병렬 에이전트 (Swarm)
verifiers = [
    Agent(name="security", prompt="보안 관점 리뷰"),
    Agent(name="performance", prompt="성능 관점 리뷰"),
    Agent(name="quality", prompt="코드 품질 리뷰")
]
swarm = Swarm(agents=verifiers)
results = await swarm.run_parallel(task)
```

**MCP 설정 예시:**
```json
{
  "mcpServers": {
    "context7": {
      "command": "npx",
      "args": ["-y", "@context7/mcp-server"]
    }
  }
}
```

---

## 주의사항

### AI Slop 금지
AI가 생성한 코드를 **검증 없이** 그대로 쓰지 마세요.
아무리 좋은 모델이라도 **마지막 터치는 당신이** 해야 합니다.

### 코드는 부채다
```
코드 = 자산 ✗
코드 = 부채 ✓

유지보수 부담, 버그, 기술 부채
→ 필요한 최소한의 코드만 유지
```

### 보안 주의
- API 키 하드코딩 절대 금지
- 민감 데이터 프롬프트에 넣지 않기
- AI 생성 코드도 반드시 보안 검토

---

## 실천 로드맵

| 주차 | 목표 |
|------|------|
| 1주차 | CLAUDE.md 작성, Rule-Growing 시작 |
| 2주차 | 첫 번째 Skill 완성, 팀 공유 |
| 3주차 | MCP 연동, 병렬 검증 도입 |
| 4주차 | 전체 워크플로우 완성 |

---

## 마무리: 새로운 시대의 개발자

```
┌────────────────────────────────────────────────────┐
│                                                     │
│   "현재 모델의 성능을 100% 사용하는 사람은         │
│    거의 없다"                                       │
│                                                     │
│   → 도구 사용법보다 마인드셋이 먼저                │
│   → A to Z 학습보다 문제 중심 학습                 │
│   → 코딩보다 문제 정의와 검증                      │
│   → 차별화는 워크플로우에서                        │
│                                                     │
└────────────────────────────────────────────────────┘
```

**기억하세요:**
- 질문을 두려워하지 마세요
- 고민을 아웃소싱하세요
- 마스터셰프가 되세요
- 나만의 워크플로우를 구축하세요

---

*AI 페어프로그래밍 3일 과정 요약 | 김학민 · SE P/J · 2026.1*
